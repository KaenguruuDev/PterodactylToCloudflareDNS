using System.Net.Http.Json;
using System.Text;
using Newtonsoft.Json;
using CloudFlare.Client;
using CloudFlare.Client.Api.Result;
using CloudFlare.Client.Api.Zones.DnsRecord;
using CloudFlare.Client.Enumerators;
using Microsoft.AspNetCore.Identity;
using PterodactylToCloudflareDNS.PterodactylApiJson;

namespace PterodactylToCloudflareDNS;

public static class CloudflareService
{
	private const int DnsAlreadyExists = 81058;

	private static string? _cloudflareApiKey;
	private static string? _zoneId;
	private static string? _panelUrl;
	private static string? _pterodactylClientApiKey;
	private static string? _pterodactylApplicationApiKey;

	private static CloudFlareClient? _cloudFlareClient;

	public static async Task Run(Dictionary<string, string?> configuration)
	{
		configuration.TryGetValue("CLOUDFLAREAPIKEY", out _cloudflareApiKey);
		configuration.TryGetValue("CLOUDFLAREZONEID", out _zoneId);
		configuration.TryGetValue("PTERODACTYLAPIURL", out _panelUrl);
		configuration.TryGetValue("PTERODACTYL_CLIENT_API_KEY", out _pterodactylClientApiKey);
		configuration.TryGetValue("PTERODACTYL_APPLICATION_API_KEY", out _pterodactylApplicationApiKey);

		try
		{
			_cloudFlareClient = new CloudFlareClient(_cloudflareApiKey);
		}
		catch (Exception ex)
		{
			await Logging.LogError("Cloudflare", $"Client creation failed: {ex.Message}");
			Environment.Exit(1);
			return;
		}

		await Logging.LogInfo("Cloudflare", "Initialize");
		var isValid = await CheckValidity();
		if (!isValid)
		{
			await Logging.LogError("Cloudflare",
				"Could not verify Cloudflare configuration. Terminating.");
			Environment.Exit(1);
			return;
		}

		await Logging.LogInfo("Cloudflare", "Configuration is valid. Monitoring...");
		await MonitorForChanges();
	}

	private static async Task<bool> CheckValidity()
	{
		if (_cloudflareApiKey == null || _zoneId == null || _cloudFlareClient == null)
			return false;

		var dnsRecord = new NewDnsRecord()
		{
			Type = DnsRecordType.A,
			Name = "ptcf",
			Content = "127.0.0.1",
			Ttl = 1,
			Proxied = false,
			Comment = "API Key Verification Record || Generated by PTCF",
		};

		try
		{
			var result = await _cloudFlareClient.Zones.DnsRecords.AddAsync(_zoneId, dnsRecord);
			return result is { Success: true } ||
			       (result.Errors.Count == 1 && result.Errors[0].Code == DnsAlreadyExists);
		}
		catch (Exception e)
		{
			await Logging.LogError("Cloudflare", "Error adding DnsRecord: " + e.Message);
			return false;
		}
	}

	private static async Task MonitorForChanges()
	{
		while (true)
		{
			await Logging.LogDebug("CF/Monitor", $"Starting DNS refresh...");

			var servers = await UpdateServerList();

			// Pterodactyl API was unavailable. To avoid deleting all records, we return early.
			if (servers is [{ Data: null }])
			{
				await Logging.LogDebug("CF/Monitor", "Refresh process cancelled. Continuing...");
				await Task.Delay(TimeSpan.FromSeconds(30));
				continue;
			}

			var recordsRequest = await _cloudFlareClient!.Zones.DnsRecords.GetAsync(_zoneId);

			var existingRecords = recordsRequest.Result
				.Where(record => record.Type is DnsRecordType.A or DnsRecordType.Srv)
				.Where(record => record.Comment == "Generated by PTCF").ToArray();

			var srvRecordData = existingRecords.Where(r => r.Type == DnsRecordType.Srv)
				.Select(r => JsonConvert.DeserializeObject<SrvRecordData>(JsonConvert.SerializeObject(r.Data)))
				.Where(r => r != null).ToArray();

			var newServers = servers.Where(s => s.Data != null &&
			                                    existingRecords.All(r =>
				                                    (r.Type is DnsRecordType.A &&
				                                     r.Name != $"{s.Data.Subdomain}.{s.Data.Domain}") ||
				                                    r.Type == DnsRecordType.Srv)).ToArray();

			var changedServers = servers.Where(s => !newServers.Contains(s)).Where(server =>
					srvRecordData.All(r =>
						r!.Target != $"{server.Data!.Subdomain}.{server!.Data.Domain}" || r.Port != server.Data!.Port))
				.ToArray();

			var unusedRecords = existingRecords.Where(record =>
				record.Type == DnsRecordType.A &&
				servers.All(s => record.Name != $"{s.Data!.Subdomain}.{s.Data!.Domain}") ||
				record.Type == DnsRecordType.Srv && servers.All(s =>
					srvRecordData.First(r => record.Content.Split(" ")[2] == r!.Target)!.Target !=
					$"{s.Data!.Subdomain}.{s.Data!.Domain}")).ToArray();

			await Logging.LogDebug("CF/Monitor", "Adding new servers...");

			foreach (var server in newServers)
			{
				await CreateServerRecords(server);
				await Task.Delay(1);
			}

			await Logging.LogDebug("CF/Monitor", "Updating existing servers...");

			foreach (var server in changedServers)
			{
				await UpdateServerRecords(server,
					existingRecords.First(r =>
						r.Type == DnsRecordType.A && r.Name == $"{server.Data!.Subdomain}.{server.Data!.Domain}"),
					existingRecords.First(r =>
						r.Type == DnsRecordType.Srv &&
						r.Content.Split(" ")[2] == $"{server.Data!.Subdomain}.{server.Data!.Domain}"));
				await Task.Delay(1);
			}

			await Logging.LogDebug("CF/Monitor", "Deleting unused records...");

			foreach (var record in unusedRecords)
				await _cloudFlareClient.Zones.DnsRecords.DeleteAsync(_zoneId, record.Id);	

			await Logging.LogDebug("CF/Monitor", $"Finished DNS refresh...");
			await Task.Delay(TimeSpan.FromSeconds(30));
		}
	}

	private static async Task CreateServerRecords(SingleServerQueryResponse server)
	{
		await Logging.LogDebug("CF/DNS", $"Creating A Record for {server.Data!.Subdomain}.{server.Data!.Domain}");

		var aRecord = GenerateARecord(server);
		var aRecordResult = await _cloudFlareClient!.Zones.DnsRecords.AddAsync(_zoneId, aRecord);

		await Logging.LogDebug("CF/DNS", $"Creating SRV for {server.Data!.Subdomain}.{server.Data!.Domain}");

		var srvRecord = GenerateSRVRecord(server);
		var content = new StringContent(JsonConvert.SerializeObject(srvRecord), Encoding.UTF8,
			"application/json");
		var srvRecordResult = await Api.Post($"https://api.cloudflare.com/client/v4/zones/{_zoneId}/dns_records",
			content, _cloudflareApiKey);

		var aRecordSuccess = aRecordResult?.Success == true;
		if (aRecordResult is null || !aRecordSuccess)
		{
			await Logging.LogWarning("CF/Monitor",
				$"Could not create A Record for: {server.Data!.Subdomain}.{server.Data!.Domain}");
		}

		if (srvRecordResult is null || !srvRecordResult.IsSuccessStatusCode)
		{
			await Logging.LogError("CF/Monitor",
				$"Could not create SRV Record for: {server.Data!.Subdomain}.{server.Data!.Domain}");
		}
	}

	private static async Task UpdateServerRecords(SingleServerQueryResponse server, DnsRecord aRecord,
		DnsRecord srvRecord)
	{
		await Logging.LogDebug("CF/DNS", $"Updating A Record for {server.Data!.Subdomain}.{server.Data!.Domain}");

		var newARecord = GenerateARecord(server);
		var modifiedARecord = new ModifiedDnsRecord()
		{
			Content = newARecord.Content,
			Name = newARecord.Name,
			Comment = newARecord.Comment,
			Priority = newARecord.Priority,
			Proxied = newARecord.Proxied,
			Tags = newARecord.Tags,
			Ttl = newARecord.Ttl,
			Type = newARecord.Type,
		};

		var aRecordResult = await _cloudFlareClient!.Zones.DnsRecords.UpdateAsync(_zoneId, aRecord.Id, modifiedARecord);
		if (aRecordResult is null || !aRecordResult.Success)
			await Logging.LogError("CF/DNS",
				$"Could not update A Record for: {server.Data!.Subdomain}.{server.Data!.Domain} ({string.Join(", ", aRecordResult?.Errors.Select(err => err.Code) ?? [])})");

		await Logging.LogDebug("CF/DNS", $"Creating SRV Record for {server.Data!.Subdomain}.{server.Data!.Domain}");

		var newSrvRecord = GenerateSRVRecord(server);
		var content = new StringContent(JsonConvert.SerializeObject(newSrvRecord), Encoding.UTF8,
			"application/json");
		var srvRecordResult = await Api.Put(
			$"https://api.cloudflare.com/client/v4/zones/{_zoneId}/dns_records/{srvRecord.Id}",
			content, _cloudflareApiKey);

		if (srvRecordResult is null || !srvRecordResult.IsSuccessStatusCode)
			await Logging.LogError("CF/DNS",
				$"Could not update SRV Record for: {server.Data!.Subdomain}.{server.Data!.Domain} ({srvRecordResult?.ReasonPhrase})");
	}

	private static async Task<SingleServerQueryResponse[]> UpdateServerList()
	{
		await Logging.LogDebug("CF/Monitor", $"Querying '{_panelUrl}/api/application/servers' with key '{_pterodactylClientApiKey}'");

		var response = await Api.Get(_panelUrl + "/api/application/servers", _pterodactylClientApiKey);
		if (response?.IsSuccessStatusCode ?? false)
		{
			var newServerList = await response.Content.ReadFromJsonAsync<MultiServerQueryResponse>() ??
			                    new MultiServerQueryResponse();
			await Logging.LogDebug("CF/Monitor", $"Found {newServerList.Data.Length} servers");

			List<SingleServerQueryResponse> serverData = [];
			foreach (var server in newServerList.Data)
			{
				var serverResponse = await Api.Get(
					$"{_panelUrl}/api/client/extensions/dnssubdomains/servers/{server.Attributes.Identifier}/dns-config",
					_pterodactylClientApiKey);
				if (serverResponse is null || !serverResponse.IsSuccessStatusCode)
				{
					await Logging.LogDebug("CF/Monitor", $"Could not reach server '{server.Attributes.Uuid}': {serverResponse?.RequestMessage}");
					continue;
				}

				var serverInfo = await serverResponse.Content.ReadFromJsonAsync<SingleServerQueryResponse>();
				if (serverInfo is null || !serverInfo.Success || serverInfo.Data is null)
				{
					await Logging.LogDebug("CF/Monitor", "Could not parse server '{server.Attributes.Uuid}'");
					continue;
				}

				serverData.Add(serverInfo);
			}

			return serverData.ToArray();
		}

		await Logging.LogWarning("CF/Monitor", "Could not reach minimal Pterodactyl API");
		return [new SingleServerQueryResponse() { Data = null, }];
	}

	// ReSharper disable once InconsistentNaming
	private static dynamic GenerateSRVRecord(SingleServerQueryResponse server)
	{
		var srvRecord = new
		{
			type = "SRV",
			name = $"_minecraft._tcp.{server.Data!.Subdomain}",
			data = new
			{
				priority = 0,
				weight = 5,
				port = server.Data!.Port.ToString(),
				target = $"{server.Data!.Subdomain}.{server.Data!.Domain}"
			},
			ttl = 1,
			proxied = false,
			comment = "Generated by PTCF",
		};

		return srvRecord;
	}

	private static NewDnsRecord GenerateARecord(SingleServerQueryResponse server)
	{
		var aRecord = new NewDnsRecord()
		{
			Type = DnsRecordType.A,
			Name = server.Data!.Subdomain,
			Content = server.Data!.Ip,
			Ttl = 1,
			Proxied = false,
			Comment = "Generated by PTCF"
		};

		return aRecord;
	}

	private record SrvRecordData(int Port, int Priority, int Weight, string Target);
}